<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" href="./static/css/bootstrap.min.css">
    <link rel="stylesheet" href="./static/css/main.css">
    <link href="https://fonts.googleapis.com/css?family=Arima+Madurai:200&display=swap" rel="stylesheet"> 
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/socket.io/1.3.6/socket.io.min.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Patua+One&display=swap" rel="stylesheet">
    <script type="text/javascript" src="./static/js/dat.gui.js"></script>
    <script type="text/javascript" src="./static/js/colorconvert.js"></script>
    <script src="./static/js/three.min.js"></script>  

<title>GUI</title>
</head>
<body  class="gradient">
    <div id="loading" class="bsapp d-flex align-items-center">
        <div class="container">
            <div class="row">
                <div id="centerb" class="col text-center">
                    <div id="processing">Processing...</div>
                    <div id="spinner" class="lds-ripple"><div></div><div></div></div>
                </div>
            </div>
        </div>  
    </div> 
<script>

let cfg = {
    amp:20,
    opacity:1,
    line_width:1,
    color_scale:0,
    hue_shift:0,
    saturation:1,
    brightness:1,
    flower: null,
    colors:null,
    ctx : null,
    bgcolor:"#000000",
    canvas:null,
    diameter:300,
    swarm:false,
    frame:300,
    depth:300,
    step:1,
    wheel:30,
    animate:false,
    req:null,
    connected:false,
    res:0.4,
    guidectx:false,
    rulers:false,
    sigpreview:false
};


var socket = io.connect('http://' + document.domain + ':' + location.port);
socket.on('connect', function() {
    console.log('Websocket connected!');
    if(cfg.connected){
        stream_batches();
    }
    else{
        cfg.connected = true;
        socket.emit('init_process',{'frame':cfg.depth,'depth':cfg.depth});

    }
});

socket.on('process_message',function(data){
    console.log('message received!');
    let message = document.getElementById('processing');
    message.innerHTML=data;
});


function setFrame(){
    // cfg.flower = slice(cfg.allFlower,Math.max(0,cfg.frame-cfg.depth),cfg.frame,cfg.step);
    cfg.raw =  slice(cfg.allRaw,Math.max(0,cfg.frame-cfg.depth),cfg.frame,cfg.step);
    cfg.colors = slice(cfg.allColor,Math.max(0,cfg.frame-cfg.depth),cfg.frame,cfg.step);
}

function zoom(event) {
            event.preventDefault();
            var dy = Math.round(event.deltaY/120);
            cfg.frame =Math.max(cfg.frame-cfg.wheel*dy,1);
            setFrame();
            draw();
            if(cfg.sigpreview){
                makeGuide();
                gradDisk();
                signal_line(cfg.previewindex);
            }
        }


socket.on('init_data',function(data){
    // cfg.allFlower = data['flower'];
    cfg.allColor = data['color'];
    cfg.allRaw = data['raw'];
    cfg.maxframes  = data['full_size'];
    cfg.labels = data['labels'];

    console.log('data received- numsamples:',data['raw'].length)
    console.log('allraw len:',cfg.allRaw.length)
    setFrame();
    var body = document.getElementsByTagName('body')[0];
    body.style.background = "#000000";

    let loading = document.getElementById('loading');
    loading.parentNode.removeChild(loading);
    

    let stack = document.createElement('div');
    stack.setAttribute('id','stack');
    let canvas = document.createElement('canvas');
    canvas.style.webkitFilter = "blur(0.3px)";
    cfg.canvas = canvas;
    canvas.width = 1800;
    canvas.height = 1800;
    canvas.style.width = "900px";
    canvas.style.height = "900px";
    canvas.setAttribute('id','flowerplot');
    ctx = canvas.getContext('2d');
    ctx.scale(2,2);
    cfg.ctx = ctx;
    document.body.appendChild(stack);
    stack.appendChild(canvas);
    draw();
    makeGuide();

    let gui = new dat.GUI();
    cfg.gui = gui;

    gui.add(cfg, 'swarm').onChange(function(value) {
        draw();
    });
    gui.add(cfg, 'rulers').onChange(function(value) {
        makeGuide();
    });
    let frame_handler = gui.add(cfg, 'frame').min(1).max(cfg.allColor.length).step(1).listen().onChange(function(value) {
        setFrame();
        draw();
    });
    cfg.frame_handler = frame_handler;
    stream_batches();

    gui.add(cfg, 'depth').min(10).max(1000).step(1).onChange(function(value) {
        setFrame();
        draw();
    });
    gui.add(cfg, 'step').min(1).max(10).step(1).onChange(function(value) {
        setFrame();
        draw();
    });
    gui.add(cfg, 'amp').min(0.1).max(40).step(0.1).onChange(function(value) {
        draw();
        makeGuide();

    });
    gui.add(cfg, 'diameter').min(0.1).max(600).step(0.1).onChange(function(value) {
        draw();
        makeGuide();
    });
    gui.add(cfg, 'res').min(0.1).max(1.5).step(0.1).onChange(function(value) {
        draw();
    });
    gui.add(cfg, 'opacity').min(0.01).max(1).step(0.01).onChange(function(value) {
        draw();
    });

    gui.add(cfg, 'line_width').min(0.01).max(5).step(0.01).onChange(function(value) {
        draw();
    });
    gui.add(cfg, 'color_scale').min(-256).max(256).step(0.01).onChange(function(value) {
        draw();
    });

    gui.add(cfg, 'hue_shift').min(0).max(1).step(0.01).onChange(function(value) {
        draw();
    });

    gui.add(cfg, 'saturation').min(0.01).max(1).step(0.01).onChange(function(value) {
        draw();
    });

    gui.add(cfg, 'brightness').min(0.01).max(2).step(0.01).onChange(function(value) {
        draw();
    });

    gui.add(cfg, 'wheel').min(1).max(60).step(1);
    
    gui.add(cfg, 'animate').onChange(function(value){
        if(value){
            animate();
        }
        else{
            cancelAnimationFrame(cfg.req);
        }
    });

    })

function stream_batches(){
    let d = Math.min(50000,cfg.maxframes-cfg.allColor.length)
    let frame = cfg.allColor.length + d;
    socket.emit('batch',{'frame':frame,'depth':d});
}



socket.on('batch_data',function(data){
    cfg.allColor = cfg.allColor.concat(data['color']);
    cfg.allRaw = cfg.allRaw.concat(data['raw']);
    cfg.frame_handler.max(cfg.allColor.length);
    if(cfg.allColor.length<cfg.maxframes){
        stream_batches();
    }
})


function animate(){
    cfg.frame = (cfg.frame+cfg.wheel)%(cfg.allColor.length-1);
    setFrame();
    draw();
    if(cfg.sigpreview){
                makeGuide();
                gradDisk();
                signal_line(cfg.previewindex);
            }
    cfg.req= requestAnimationFrame(animate);

}

function draw(slow=false){
    if(cfg.swarm){
        swarm(slow)
    }
    else{
        drawFlower(slow)
    }
}

function colorize(col){
    cs= cfg.color_scale;
    let cols = [cs+256*col[0],cs+256*col[1],cs+256*col[2]];
    cols = rgbToHsl(...cols);
    cols = hslToRgb(cfg.hue_shift+cols[0]-Math.floor(cfg.hue_shift+cols[0]), cfg.saturation*cols[1], cfg.brightness*cols[2]);
    return cols;
}


async function swarm(slow=false){
    let diameter = cfg.diameter;
    let amp =cfg.amp;
    let opacity = cfg.opacity;
    let ctx = cfg.ctx;
    let cs = cfg.color_scale
    let raw = cfg.raw;
    let colors = cfg.colors;
    const num_points = raw[0].length;
    const num_samples = raw.length;
    ctx.fillStyle = cfg.bgcolor;
    ctx.fillRect(0, 0, cfg.canvas.width, cfg.canvas.height);
    // var canvasData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
    //ctx.putImageData(canvasData, 0, 0);


    for(let t=0;t<num_samples;t++){
        for(let i=0;i<num_points-4;i++){
            let j=i+1;
            let k=i+2;
            let l=i+3;
            let m=i+4;
            function layout(xs,ys){
                function makePoint(a,b,c){
                    x=450+xs*(Math.sqrt(diameter)+amp)*(raw[t][a]-raw[t][b]);
                    y=450+ys*(Math.sqrt(diameter)+amp)*(raw[t][a]-raw[t][c]);
                    ctx.fillRect(x,y,cfg.line_width,cfg.line_width);
                }
                makePoint(i,j,k);
                makePoint(j,k,l);
                makePoint(k,l,m);
                makePoint(l,m,i);
                makePoint(m,i,j);
            }
            cols =colorize(colors[t]);
            ss = `rgba(${cols[0]},${cols[1]},${cols[2]},${opacity*t/num_samples})`;
            ctx.fillStyle = ss;

            layout(1,1);
            layout(-1,-1);
            layout(1,-1);
            layout(-1,1);
        }
    }
}



async function drawFlower(slow=false){
    let diameter=cfg.diameter;
    let amp=cfg.amp;
    let line_width = cfg.line_width;
    let opacity = cfg.opacity;
    let ctx = cfg.ctx;
    let cs = cfg.color_scale
    let raw = cfg.raw;
    let colors = cfg.colors;
    const num_chans = raw[0].length;
    const num_samples = raw.length;


    ctx.clearRect(0, 0, cfg.canvas.width, cfg.canvas.height);
    
    for(let i=0;i<num_samples-1;i++){

        let vectors = raw[i].map((v,k)=>{
            let theta = -2*Math.PI*k/(num_chans)
            let r =  0.1+(diameter+amp*v)*i/num_samples;
            let x = 450+r*Math.cos(theta);
            let y = 450+r*Math.sin(theta);
            let z = 0;
            return new THREE.Vector3( x, y, z );
        });
        let curve = new THREE.CatmullRomCurve3(vectors,closed=true);
        let points = curve.getPoints( num_chans+Math.floor(cfg.res*i) );
        let num_points = points.length;        
        for(let j=0; j<num_points;j++){

            let x1 = points[j].x;
            let y1 = points[j].y;
            let x2 = points[(j+1)%num_points].x;
            let y2 = points[(j+1)%num_points].y;

            ctx.beginPath(); 
            // Staring point
            ctx.moveTo(x1,y1);
            // End point 
            ctx.lineTo(x2,y2);
            // Make the line visible
        
            // Set Color
            cols =colorize(colors[i]);
            ss = `rgba(${cols[0]},${cols[1]},${cols[2]},${opacity*i/num_samples})`;
            ctx.strokeStyle = ss;
            ctx.lineWidth = line_width;

            ctx.stroke();
        }
    }
}

function makeGuide(){
    if(!cfg.guidectx){
        let canvas = document.createElement('canvas');
        cfg.guidecanvas = canvas;
        canvas.addEventListener('wheel',zoom);
        canvas.width = 1800;
        canvas.height = 1800;
        canvas.style.width = "900px";
        canvas.style.height = "900px";
        let ctx = canvas.getContext('2d');
        ctx.scale(2,2);
        cfg.guidectx = ctx;
        let stack = document.getElementById('stack');
        stack.appendChild(canvas);
    }
    let canvas = cfg.guidecanvas;
    let labels = cfg.labels;
    let num_chans = labels.length
    let ctx = cfg.guidectx;
    ctx.clearRect(0, 0, cfg.canvas.width, cfg.canvas.height);

    ctx.beginPath();
    ctx.arc(450, 450, (cfg.diameter+2*cfg.amp), 0, 2 * Math.PI, false);      
    ctx.lineWith = 5;
    ctx.strokeStyle = '#aaaaaa';
    ctx.stroke();

    for(let i=0;i<labels.length;i++){
        let r = 20+(cfg.diameter+2*cfg.amp)
        let theta = -Math.PI*2*i/num_chans;
        let x = 450+r*Math.cos(theta);
        let y = 450+r*Math.sin(theta);
        ctx.save();
        ctx.translate(x, y);
        if (i<=(num_chans/4) || i>=(3*(num_chans/4))){
            ctx.rotate(theta);}
        else{
            ctx.rotate(Math.PI+theta);}
        ctx.font = "15px monospace";
        ctx.textAlign = "center";
        ctx.fillStyle = '#aaaaaa';
        ctx.fillText(labels[i], 0, 0);
        ctx.restore();
    }

    if(cfg.rulers){
        ctx.lineWith = 1;
        let r = (cfg.diameter+2*cfg.amp)
        for(let j=0;j<labels.length;j++){
            let theta = Math.PI*2*j/num_chans;
            let shift = Math.PI/num_chans;
            let x1 = 450+r*Math.cos(theta+shift);
            let y1 = 450+r*Math.sin(theta+shift);
            let x2 = 450+r*Math.cos(theta+shift)/10;
            let y2 = 450+r*Math.sin(theta+shift)/10;


            let gradient = ctx.createLinearGradient(x1, y1, x2, y2);
            gradient.addColorStop("0", 'rgba(255,255,255,0.7)');
            gradient.addColorStop("1.0", 'rgba(255,255,255,0.0)');
            ctx.beginPath();
            ctx.moveTo(x1,y1);
            ctx.lineTo(x2,y2);
            ctx.strokeStyle = gradient;
            ctx.stroke();
    }

    }

    canvas.addEventListener('mousemove',channelHighlight);

}

function channelHighlight(e){
    let rmin = cfg.diameter+2*cfg.amp;
    let rmax = 30+rmin;
    let rect = this.getBoundingClientRect();
    let x = e.clientX - rect.left-450;
    let y = 450-e.clientY - rect.top;
    let r = Math.sqrt((x*x)+(y*y));
    if(r>=rmin && r<=rmax){
        let labels = cfg.labels;
        let num_labels = labels.length;
        let theta = Math.atan2(y,x);
        if(theta<0){theta += 2*Math.PI}
        index = Math.round(num_labels*theta/(2*Math.PI))%num_labels;
        if(index!=cfg.previewindex){
            makeGuide();
            gradDisk();
            signal_line(index);
            cfg.previewindex = index;
            cfg.sigpreview = true;
        }
        
    }
    else if(cfg.sigpreview){
        makeGuide();
        cfg.sigpreview =  false;
        cfg.previewindex = -1;
    }
}

function gradDisk(){
    let ctx = cfg.guidectx;
    let H = 2*(cfg.diameter+2*cfg.amp);
    let grd = ctx.createLinearGradient(450, 450-H/3, 450, 450+H/3);
    // Add colors
    grd.addColorStop(0.000, 'rgba(0, 0, 0, 0.000)');
    grd.addColorStop(0.4500, 'rgba(0, 0, 0, 1.000)');
    grd.addColorStop(0.5500, 'rgba(0, 0, 0, 1.000)');
    grd.addColorStop(1.000, 'rgba(0, 0, 0, 0.000)');

    // Fill with gradient
    ctx.fillStyle = grd;
    // ctx.fillRect(xr, yr, W, H);
    ctx.beginPath();
    ctx.arc(450,450,H/2,2*Math.PI,false);
    ctx.fill();
}

function signal_line(ind){

    let amp = 17;
    let ctx = cfg.guidectx;
    let W = 0.9*2*(cfg.diameter+2*cfg.amp);
    let data = cfg.raw;
    let color = cfg.colors;
    for(let i=0;i<data.length-1;i++){
        let x1 = 450 - W/2 + i*W/data.length;
        let x2 = 450 - W/2 + (i+1)*W/data.length;
        let y1 = 450-amp*data[i][ind];
        let y2 = 450-amp*data[i+1][ind];
        cols1 =colorize(color[i]);
        ss1 = `rgba(${cols1[0]},${cols1[1]},${cols1[2]},${1})`;
        cols2 =colorize(color[i+1]);
        ss2 = `rgba(${cols2[0]},${cols2[1]},${cols2[2]},${1})`;
        let lineGrad = ctx.createLinearGradient(x1,y1,x2,y2);
        lineGrad.addColorStop(0.000, ss1);
        lineGrad.addColorStop(1.000, ss2);

        ctx.beginPath();
        ctx.save();
        ctx.shadowColor = 'white';
        ctx.shadowBlur = 2;
        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.strokeStyle = lineGrad;
        ctx.stroke();
        ctx.restore();
    }
    ctx.font = "25px monospace";
    ctx.textAlign = "center";
    ctx.fillStyle = '#cccccc';
    ctx.fillText(cfg.labels[ind], 450, 370);
      
}

</script>

</body>
</html>